'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* eslint-disable no-use-before-define */


var _reactUtils = require('./internal/reactUtils');

var _updateCounter = require('./updateCounter');

var _proxies = require('./reconciler/proxies');

function resolveType(type) {
  if (!(0, _reactUtils.isCompositeComponent)(type)) return type;

  const proxy = reactHotLoader.disableProxyCreation ? (0, _proxies.getProxyByType)(type) : (0, _proxies.createProxyForType)(type);

  return proxy ? proxy.get() : type;
}

const reactHotLoader = {
  register(type, uniqueLocalName, fileName) {
    if ((0, _reactUtils.isCompositeComponent)(type) && typeof uniqueLocalName === 'string' && uniqueLocalName && typeof fileName === 'string' && fileName) {
      (0, _updateCounter.didUpdate)();
      (0, _proxies.updateProxyById)(`${fileName}#${uniqueLocalName}`, type);
    }
  },

  reset() {
    (0, _proxies.resetProxies)();
  },

  patch(React) {
    if (!React.createElement.isPatchedByReactHotLoader) {
      const originalCreateElement = React.createElement;
      // Trick React into rendering a proxy so that
      // its state is preserved when the class changes.
      // This will update the proxy if it's for a known type.
      React.createElement = (type, ...args) => originalCreateElement(resolveType(type), ...args);
      React.createElement.isPatchedByReactHotLoader = true;
    }

    if (!React.createFactory.isPatchedByReactHotLoader) {
      // Patch React.createFactory to use patched createElement
      // because the original implementation uses the internal,
      // unpatched ReactElement.createElement
      React.createFactory = type => {
        const factory = React.createElement.bind(null, type);
        factory.type = type;
        return factory;
      };
      React.createFactory.isPatchedByReactHotLoader = true;
    }

    if (!React.Children.only.isPatchedByReactHotLoader) {
      const originalChildrenOnly = React.Children.only;
      // Use the same trick as React.createElement
      React.Children.only = children => originalChildrenOnly(_extends({}, children, { type: resolveType(children.type) }));
      React.Children.only.isPatchedByReactHotLoader = true;
    }

    reactHotLoader.reset();
  },

  disableProxyCreation: false,

  config: {
    logLevel: 'error'
  }
};

exports.default = reactHotLoader;