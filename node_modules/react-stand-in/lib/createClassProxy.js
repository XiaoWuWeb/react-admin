'use strict';

exports.__esModule = true;

var _react = require('react');

var _transferStaticProps = require('./transferStaticProps');

var _transferStaticProps2 = _interopRequireDefault(_transferStaticProps);

var _constants = require('./constants');

var _utils = require('./utils');

var _inject = require('./inject');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const proxies = new WeakMap();

function createClassProxy(InitialComponent, proxyKey, wrapResult = _utils.identity) {
  // Prevent double wrapping.
  // Given a proxy class, return the existing proxy managing it.
  const existingProxy = proxies.get(InitialComponent);

  if (existingProxy) {
    return existingProxy;
  }

  let CurrentComponent;
  let savedDescriptors = {};
  let injectedMembers = {};
  let proxyGeneration = 0;
  let isFunctionalComponent = !(0, _utils.isReactClass)(InitialComponent);

  class StatelessProxyComponent extends _react.Component {
    render() {
      return CurrentComponent(this.props, this.context);
    }
  }

  const InitialParent = isFunctionalComponent ? StatelessProxyComponent : InitialComponent;

  let lastInstance = null;

  class ProxyComponent extends InitialParent {
    constructor(props, context) {
      super(props, context);

      this[_constants.GENERATION] = 0;

      // As long we can't override constructor
      // every class shall evolve from a base class
      (0, _inject.inject)(this, proxyGeneration, injectedMembers);

      lastInstance = this;
    }

    // for beta testing only
    componentWillUnmount() {
      if (!isFunctionalComponent) {
        if (CurrentComponent.prototype.componentWillUnmount) {
          CurrentComponent.prototype.componentWillUnmount.call(this);
        }
      }
    }

    render() {
      (0, _inject.inject)(this, proxyGeneration, injectedMembers);

      const result = isFunctionalComponent ? CurrentComponent(this.props, this.context) : CurrentComponent.prototype.render.call(this);

      return wrapResult(result);
    }
  }

  function get() {
    return ProxyComponent;
  }

  function getCurrent() {
    return CurrentComponent;
  }

  (0, _utils.safeDefineProperty)(ProxyComponent, _constants.UNWRAP_PROXY, {
    configurable: false,
    writable: false,
    enumerable: false,
    value: getCurrent
  });

  (0, _utils.safeDefineProperty)(ProxyComponent, _constants.PROXY_KEY, {
    configurable: false,
    writable: false,
    enumerable: false,
    value: proxyKey
  });

  (0, _utils.safeDefineProperty)(ProxyComponent, 'toString', {
    configurable: true,
    writable: false,
    enumerable: false,
    value: function toString() {
      return String(CurrentComponent);
    }
  });

  function update(NextComponent) {
    if (typeof NextComponent !== 'function') {
      throw new Error('Expected a constructor.');
    }

    if (NextComponent === CurrentComponent) {
      return;
    }

    // Prevent proxy cycles
    const existingProxy = proxies.get(NextComponent);
    if (existingProxy) {
      update(existingProxy[_constants.UNWRAP_PROXY]());
      return;
    }

    isFunctionalComponent = !(0, _utils.isReactClass)(NextComponent);
    proxyGeneration++;
    injectedMembers = {};

    // Save the next constructor so we call it
    const PreviousComponent = CurrentComponent;
    CurrentComponent = NextComponent;

    // Try to infer displayName
    const displayName = (0, _utils.getDisplayName)(CurrentComponent);
    ProxyComponent.displayName = displayName;

    (0, _utils.safeDefineProperty)(ProxyComponent, 'name', {
      value: displayName
    });

    savedDescriptors = (0, _transferStaticProps2.default)(ProxyComponent, savedDescriptors, PreviousComponent, NextComponent);

    if (isFunctionalComponent) {
      ProxyComponent.prototype.prototype = StatelessProxyComponent.prototype;
    } else {
      (0, _inject.checkLifeCycleMethods)(ProxyComponent, NextComponent);
      Object.setPrototypeOf(ProxyComponent.prototype, NextComponent.prototype);
      if (proxyGeneration > 1) {
        injectedMembers = (0, _inject.mergeComponents)(ProxyComponent, NextComponent, InitialComponent, lastInstance);
      }
    }
  }

  update(InitialComponent);

  const proxy = { get, update };
  proxies.set(ProxyComponent, proxy);

  Object.defineProperty(proxy, _constants.UNWRAP_PROXY, {
    configurable: false,
    writable: false,
    enumerable: false,
    value: getCurrent
  });

  return proxy;
}

exports.default = createClassProxy;